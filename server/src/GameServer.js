'use strict';var net = require("net")  , util = require('util')  , bunyan = require('bunyan')  , config = require('../config')  , log = bunyan.createLogger({ name: "game" });var MultiplayerServer = require('./MultiplayerServer');class GameServer {  constructor(room) {    this.dotsRemaining = 0;    this.clicked = [];    this.finished = false;    this.map = 'w';    this.room = room;    this.port = config.gamePort + room;    this.log = bunyan.createLogger({ name: 'game-' + room });    this.generateMap();    this.server = new MultiplayerServer();    var server = this.server;    var game = this;    server.on('connection', user => {      user.name = '???';      user.color1 = '0xffffff';      user.color2 = '0x000000';      user.score = 0;      user.id = '0';      user.fullname = user.name + '`' + user.id;      user.index = server.count();      user.infoPacket = '';      user.ready = false;    });    server.on('data', (user, data) => {      switch(data[0]) {        case 'i':          var arg = data.substr(1).split('`');          user.name = arg[0]          user.id = arg[1]          user.color1 = arg[2]          user.color2 = arg[3];          user.fullname = user.name+'`'+user.id;          user.ready = true;          user.infoPacket = 'i' + [user.fullname, user.color1, user.color2, user.index].join('`');          server.writeAll(user.infoPacket);          // TODO: Fix me - Sometimes information doesn't reach the user          server.each(function(u) {            if(u.ready && u !== user)              user.write(u.infoPacket);          });          user.write(game.map);          break;        case 'm': // Mouse movement array          user.writeOthers(data); // TODO: Fix this, lazy hack.          break;        case 'x': // Dot clicked          var dot = data.substr(1);          if(this.clicked[dot]) break;          this.clicked[dot] = true;          user.score++;          server.writeAll('x' + user.index + dot);          this.remaining--;          if(this.remaining == 0)            game.finish();          break;        case 'e': // Game ended          this.finish();          break;        default: this.log.warn('Unknown game server packet: %s', data);      }    });    server.on('close', () => {      this.log.info('Game server %d shutting down', game.room);    });    server.start(config.gamePort + room, () => {      this.log.info('Game server %d running on port %d', game.room, game.port);    });  }  close() {    this.finish();  }  generateMap() {    if(!config.debug) {      var result = [];      var sizeModifier = this.random(-5, 5);      var dots = this.random(20, 70);      for(var i = 0; i < dots; i++) {        var size = this.random(17, 43) + sizeModifier; // 35px to 85px in size        var dot = [this.random(size, 550), this.random(size, 400), size * 2];        result.push(dot.join('`'));      }    } else {      var dots = 1;      var dot = [275, 200, 300];      var result = [dot.join('`')];    }    this.remaining = dots;    this.map = 'w' + result.join(',');  }  finish() {    if(this.finished) return; // Only finish once (lol)    this.finished = true;    var winningScore = 0;    var winners = "";    var score = []    this.server.each(user => {      if(!user.ready) return;      if(user.score > winningScore) {        winners = user.name;        winningScore = user.score;      } else if(user.score == winningScore) {        winners += ' and ' + user.name;      }      score.push(user.index + user.score);    });    this.log.info('Game won by %s with a score of %d', winners, winningScore);    this.server.writeAll('k' + score.join('`'));    this.server.close();  }  random(min, max) {    if(max === undefined) {      max = min;      min = 0;    }    return Math.floor(Math.random() * (max - min + 1)) + min;  }}module.exports = GameServer;